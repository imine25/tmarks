import{S as p,g as x,d as l,P as T}from"./index-DlUqGJ2w.js";import{A as m,g as I}from"./index-B3uGW65S.js";import{c as _}from"./index-AGxGDhI7.js";import"./prompts-CZcZabTo.js";class b{client=null;async initialize(){const t=await p.getBookmarkSiteApiUrl(),e=await p.getBookmarkSiteApiKey();if(!e)throw new m("API_KEY_INVALID","TMarks API key is required. Please configure your API key in the extension settings.");let o;t?t.endsWith("/api")?o=t:o=x(t).API_BASE:o=x().API_BASE,this.client=_({apiKey:e,baseUrl:o})}async ensureClient(){if(this.client||await this.initialize(),!this.client)throw new m("API_KEY_INVALID","Failed to initialize TMarks client");return this.client}async getTags(){const t=await this.ensureClient();try{return(await t.tags.getTags()).data.tags.map(o=>({name:o.name,color:o.color,count:o.bookmark_count||0,createdAt:new Date(o.created_at).getTime()}))}catch(e){throw e.code==="MISSING_API_KEY"?new m("API_KEY_INVALID","TMarks API key is required. Please configure your API key in the extension settings.",{originalError:e}):new m("BOOKMARK_SITE_ERROR",`Failed to fetch tags: ${e.message}`,{originalError:e})}}async getBookmarks(t=1,e=100){const o=await this.ensureClient();try{const a=await o.bookmarks.getBookmarks({page_size:e,page_cursor:t>1?`page_${t}`:void 0});return a.data.bookmarks.length?{bookmarks:a.data.bookmarks.map(n=>({url:n.url,title:n.title,description:n.description||"",tags:n.tags.map(s=>s.name),createdAt:new Date(n.created_at).getTime(),remoteId:n.id,isPublic:n.is_public})),hasMore:a.data.meta.has_more}:{bookmarks:[],hasMore:!1}}catch(a){throw new m("BOOKMARK_SITE_ERROR",`Failed to fetch bookmarks: ${a.message}`,{originalError:a})}}async addBookmark(t){const e=await this.ensureClient();try{const o=await e.bookmarks.createBookmark({title:t.title,url:t.url,description:t.description,cover_image:t.thumbnail,favicon:t.favicon,tags:t.tags,is_public:t.isPublic??!1});if(!o.data.bookmark)throw new m("BOOKMARK_SITE_ERROR","Failed to add bookmark: No data returned");const a=o.meta?.code==="BOOKMARK_EXISTS";return a?(console.log("[BookmarkAPI] 书签已存在, ID:",o.data.bookmark.id),{id:o.data.bookmark.id,isExisting:a,existingBookmark:o.data.bookmark}):(console.log("[BookmarkAPI] 书签创建成功, ID:",o.data.bookmark.id),{id:o.data.bookmark.id,isExisting:a})}catch(o){const a=o.message||"Unknown error";throw new m("BOOKMARK_SITE_ERROR",`Failed to add bookmark: ${a}`,{originalError:o})}}async updateBookmarkTags(t,e){const o=await this.ensureClient();try{console.log("[BookmarkAPI] Updating tags for bookmark:",t,e),await o.bookmarks.updateBookmark(t,{tags:e}),console.log("[BookmarkAPI] Tags updated successfully")}catch(a){throw new m("BOOKMARK_SITE_ERROR",`Failed to update tags: ${a.message}`,{originalError:a})}}async createSnapshot(t,e){const o=await this.ensureClient();try{await o.snapshots.createSnapshot(t,e),console.log("[BookmarkAPI] Snapshot created successfully for bookmark:",t)}catch(a){throw new m("BOOKMARK_SITE_ERROR",`Failed to create snapshot: ${a.message}`,{originalError:a})}}async testConnection(){try{return await(await this.ensureClient()).user.getMe(),!0}catch(t){return console.error("API connection test failed:",t),!1}}}const h=new b;class v{contextCache=null;contextPromise=null;async recommendTags(t){try{const e=p.loadConfig(),o=this.getContext(),a=await e,r=a.aiConfig.apiKeys[a.aiConfig.provider];if(!r)return console.warn("[TagRecommender] No API key configured, using fallback"),this.fallbackRecommendation(t);const n=await o,s={page:{title:t.title,url:t.url,description:t.description,content:t.content?.substring(0,500)},context:n,options:{maxTags:a.preferences.maxSuggestedTags||5,preferExisting:!0}},c=a.aiConfig.apiUrls?.[a.aiConfig.provider],u=a.aiConfig.enableCustomPrompt?a.aiConfig.customPrompt:void 0,d=await this.callAIWithRetry(s,r,a.aiConfig.provider,a.aiConfig.model,c,u,1,void 0),g=n.existingTags,f=new Set(g.map(k=>k.trim().toLowerCase()));console.log("[TagRecommender] 开始修正 isNew 字段, 已有标签数量:",g.length),console.log("[TagRecommender] AI 返回的标签:",d.suggestedTags);const w=d.suggestedTags.map(k=>{const S=k.name.trim().toLowerCase(),B=f.has(S),A={...k,isNew:!B};return console.log(`[TagRecommender] 标签 "${k.name}": AI判断 isNew=${k.isNew}, 实际应为 isNew=${A.isNew}, 在已有标签中? ${B}`),A}),C=this.deduplicateAndSort(w);return console.log("[TagRecommender] 已修正 isNew 字段 (最终结果):",C),{tags:C,source:"ai",timestamp:Date.now()}}catch(e){console.error("[TagRecommender] AI recommendation failed:",e);const o=e instanceof Error?e.message:"AI recommendation failed";return this.fallbackRecommendation(t,o)}}async getContext(){if(this.contextCache)return this.contextCache;if(this.contextPromise)return this.contextPromise;this.contextPromise=this.loadContextFromDB();try{const t=await this.contextPromise;return this.contextCache=t,t}finally{this.contextPromise=null}}async callAIWithRetry(t,e,o,a,r,n,s,c){const u=I(o);let d;for(let g=0;g<s;g++)try{if(typeof c=="number"&&c>0){const w=new Promise((k,S)=>{setTimeout(()=>S(new Error("AI request timeout")),c)});return await Promise.race([u.generateTags(t,e,a,r,n),w])}return await u.generateTags(t,e,a,r,n)}catch(f){if(d=f,console.error(`[TagRecommender] AI call attempt ${g+1} failed:`,f),g<s-1){const w=Math.pow(2,g)*1e3;await this.delay(w)}}throw d||new Error("AI request failed after retries")}async fallbackRecommendation(t,e){console.log("[TagRecommender] ⚠️ Using fallback recommendation (AI failed)");const o=this.extractKeywords(t.title+" "+(t.description||"")),r=(await l.tags.toArray()).filter(n=>o.some(s=>n.name.toLowerCase().includes(s.toLowerCase())||s.toLowerCase().includes(n.name.toLowerCase()))).sort((n,s)=>(s.count||0)-(n.count||0)).slice(0,3).map(n=>({name:n.name,isNew:!1,confidence:.6}));return console.log("[TagRecommender] Fallback 返回的标签 (全部 isNew=false):",r),{tags:r,source:"fallback",timestamp:Date.now(),message:e||null}}extractKeywords(t){return t.split(/[\s\/\-_、，。！？]+/).map(e=>e.trim()).filter(e=>e.length>1).slice(0,20)}deduplicateAndSort(t){const e=new Set,o=[];for(const a of t){const r=a.name.toLowerCase().trim();e.has(r)||(e.add(r),o.push(a))}return o.sort((a,r)=>r.confidence-a.confidence)}delay(t){return new Promise(e=>setTimeout(e,t))}clearContextCache(){this.contextCache=null}async preloadContext(){if(this.contextPromise){await this.contextPromise;return}const t=this.loadContextFromDB(!0);this.contextPromise=t;try{const e=await t;this.contextCache=e}finally{this.contextPromise=null}}async refreshContextFromDB(){const t=this.loadContextFromDB(!0);this.contextPromise=t;try{const e=await t;this.contextCache=e}finally{this.contextPromise=null}}updateContextWithBookmark(t){if(!this.contextCache)return;const e=new Set(this.contextCache.existingTags.map(a=>a.toLowerCase())),o=[];for(const a of t.tags){const r=a.trim();r&&(e.has(r.toLowerCase())||(e.add(r.toLowerCase()),o.push(r)))}o.length>0&&(this.contextCache.existingTags=[...this.contextCache.existingTags,...o].slice(-200)),this.contextCache.recentBookmarks=[{title:t.title,tags:t.tags},...this.contextCache.recentBookmarks].slice(0,20)}async loadContextFromDB(t=!1){if(!t&&this.contextCache)return this.contextCache;const[e,o]=await Promise.all([l.tags.orderBy("count").reverse().limit(200).toArray().then(r=>r.map(n=>n.name)),l.bookmarks.orderBy("createdAt").reverse().limit(20).toArray().then(r=>r.map(n=>({title:n.title,tags:n.tags})))]),a={existingTags:e,recentBookmarks:o};return this.contextCache=a,a}}const y=new v;class M{async fullSync(){const t=Date.now();try{console.log("[CacheManager] Starting full sync...");const e=await h.getTags();await l.tags.clear(),await l.tags.bulkAdd(e),console.log(`[CacheManager] Synced ${e.length} tags`);let o=1,a=0;for(await l.bookmarks.clear();o<=T.MAX_PAGES;){const{bookmarks:n,hasMore:s}=await h.getBookmarks(o,T.DEFAULT_PAGE_SIZE);if(n.length>0&&(await l.bookmarks.bulkAdd(n),a+=n.length,console.log(`[CacheManager] Synced page ${o}: ${n.length} bookmarks`)),!s)break;o++}await l.updateLastSyncTime(Date.now()),await l.metadata.put({key:"totalTags",value:e.length,updatedAt:Date.now()}),await l.metadata.put({key:"totalBookmarks",value:a,updatedAt:Date.now()}),await y.refreshContextFromDB();const r=Date.now()-t;return console.log(`[CacheManager] Full sync completed in ${r}ms`),{success:!0,duration:r,stats:{tags:e.length,bookmarks:a}}}catch(e){return console.error("[CacheManager] Full sync failed:",e),{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}async incrementalSync(){try{return await l.getLastSyncTime()===0?this.fullSync():(console.log("[CacheManager] Incremental sync not implemented, falling back to full sync"),this.fullSync())}catch(t){return console.error("[CacheManager] Incremental sync failed:",t),{success:!1,error:t instanceof Error?t.message:"Unknown error"}}}async getStats(){return l.getStats()}async isCacheStale(t=24){const e=await l.getLastSyncTime();if(e===0)return!0;const o=t*60*60*1e3;return Date.now()-e>o}async autoSync(t=24){return await this.isCacheStale(t)?(console.log("[CacheManager] Cache is stale, performing auto sync"),this.incrementalSync()):(console.log("[CacheManager] Cache is fresh, skipping sync"),null)}async clearCache(){await l.clearAll(),y.clearContextCache(),console.log("[CacheManager] Cache cleared")}}const E=new M;class R{async saveBookmark(t){let e,o=!1;try{const a=await h.addBookmark(t);if(e=a.id,o=a.isExisting||!1,o&&a.existingBookmark)return{success:!0,existingBookmark:{...a.existingBookmark,needsDialog:!0},message:"书签已存在"};o?console.log("[BookmarkService] Bookmark already exists, skipping cache update"):(await l.bookmarks.add({url:t.url,title:t.title,description:t.description,tags:t.tags,createdAt:Date.now(),remoteId:a.id,isPublic:t.isPublic??!1}),await this.updateTagCounts(t.tags),y.updateContextWithBookmark({title:t.title,tags:t.tags}))}catch(a){const r=a instanceof Error?a.message:"Unknown error";if(console.error("[BookmarkService] Failed to save bookmark:",r),r.includes("Network"))return await this.queueForLaterSync(t),{success:!0,offline:!0,message:"已暂存,将在网络恢复后同步"};throw a}if(t.createSnapshot&&e)try{const[a]=await chrome.tabs.query({active:!0,currentWindow:!0});if(a&&a.id){let r;try{const n=chrome.tabs.sendMessage(a.id,{type:"CAPTURE_PAGE",options:{inlineCSS:!0,inlineImages:!0,inlineFonts:!1,removeScripts:!0,removeHiddenElements:!1,maxImageSize:5242880,timeout:3e4}}),s=new Promise((u,d)=>{setTimeout(()=>d(new Error("Capture timeout")),35e3)}),c=await Promise.race([n,s]);if(c.success)r=c.html,console.log(`[BookmarkService] Captured with SingleFile: ${(c.size/1024).toFixed(1)}KB`);else throw new Error(c.error||"Capture failed")}catch(n){console.log("[BookmarkService] SingleFile capture failed, falling back to simple capture:",n);const s=await chrome.scripting.executeScript({target:{tabId:a.id},func:()=>document.documentElement.outerHTML});if(s&&s[0]&&s[0].result)r=s[0].result,console.log("[BookmarkService] Simple capture successful");else throw new Error("Failed to capture page content")}await h.createSnapshot(e,{html_content:r,title:t.title,url:t.url}),console.log("[BookmarkService] Snapshot created successfully")}}catch(a){console.error("[BookmarkService] Failed to create snapshot:",a)}return{success:!0,bookmarkId:e,message:o?"书签已存在，已为其创建新快照":void 0}}async updateTagCounts(t){for(const e of t){const o=await l.tags.where("name").equals(e).first();o&&o.id?await l.tags.update(o.id,{count:(o.count||0)+1}):await l.tags.add({name:e,count:1,createdAt:Date.now()})}}async queueForLaterSync(t){await l.metadata.add({key:`pending_${Date.now()}`,value:t,updatedAt:Date.now()}),console.log("[BookmarkService] Bookmark queued for later sync")}async syncPendingBookmarks(){const t=await l.metadata.where("key").startsWith("pending_").toArray();let e=0;for(const o of t)try{if(o.value&&typeof o.value=="object"&&"url"in o.value&&"title"in o.value){const a=o.value;await h.addBookmark(a),await l.metadata.delete(o.key),e++,console.log("[BookmarkService] Synced pending bookmark:",a.title)}}catch(a){console.error("[BookmarkService] Failed to sync pending bookmark:",a)}return console.log(`[BookmarkService] Synced ${e}/${t.length} pending bookmarks`),e}async getPendingCount(){return await l.metadata.where("key").startsWith("pending_").count()}}const P=new R;console.log("[Background] Service worker started");y.preloadContext().catch(i=>{console.error("[Background] Failed to preload AI context:",i)});chrome.runtime.onInstalled.addListener(async i=>{console.log("[Background] Extension installed:",i.reason),i.reason==="install"?console.log("[Background] First time install"):i.reason==="update"&&console.log("[Background] Extension updated")});function F(){const i=new Date,t=new Date(i);return t.setHours(23,0,0,0),t<=i&&t.setDate(t.getDate()+1),t.getTime()-i.getTime()}async function N(){try{const i=await p.loadConfig();if(!i.preferences.autoSync)return;console.log("[Background] Running scheduled auto-sync (23:00)...");const t=await E.autoSync(i.preferences.syncInterval);t&&console.log("[Background] Auto-sync result:",t)}catch(i){console.error("[Background] Auto-sync failed:",i)}}async function D(){const i=()=>{const t=F();console.log("[Background] Next auto-sync scheduled in",Math.round(t/1e3),"seconds"),setTimeout(async()=>{await N(),i()},t)};i()}D().catch(console.error);P.syncPendingBookmarks().catch(console.error);chrome.runtime.onMessage.addListener((i,t,e)=>(O(i).then(o=>e(o)).catch(o=>{console.error("[Background] Message handler error:",o),e({success:!1,error:o instanceof Error?o.message:"Unknown error"})}),!0));async function O(i,t){switch(console.log("[Background] Received message:",i.type),i.type){case"EXTRACT_PAGE_INFO":{const[e]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!e||!e.id)throw new Error("No active tab found");const o=e.url||"";if(o.startsWith("chrome://")||o.startsWith("chrome-extension://")||o.startsWith("edge://")||o.startsWith("about:")||!o)return console.warn("[Background] Cannot access special page:",o),{success:!0,data:{title:e.title||"Untitled",url:o,description:"",content:"",thumbnail:""}};const a=async(s,c,u=3e3)=>Promise.race([chrome.tabs.sendMessage(s,c),new Promise((d,g)=>setTimeout(()=>g(new Error("Message timeout")),u))]),r=async s=>{try{const c=await chrome.tabs.get(s);return{success:!0,data:{title:c.title||"Untitled",url:c.url||"",description:"",content:"",thumbnail:""}}}catch(c){return console.error("[Background] Failed to get tab info:",c),{success:!0,data:{title:"Untitled",url:o,description:"",content:"",thumbnail:""}}}};let n=!1;try{await a(e.id,{type:"PING"},1e3),n=!0,console.log("[Background] Content script is alive")}catch(s){console.warn("[Background] Content script not responding:",s)}if(!n)try{console.log("[Background] Attempting to inject content script...");const c=chrome.runtime.getManifest().content_scripts?.[0];if(!c||!c.js||c.js.length===0)return console.error("[Background] Content script configuration not found in manifest"),await r(e.id);const u=c.js[0];console.log("[Background] Injecting content script from:",u),await chrome.scripting.executeScript({target:{tabId:e.id},files:[u]}),await new Promise(d=>setTimeout(d,300));try{await a(e.id,{type:"PING"},1e3),n=!0,console.log("[Background] Content script injected successfully")}catch(d){return console.error("[Background] Content script injection verification failed:",d),await r(e.id)}}catch(s){const c=s instanceof Error?s.message:"Unknown error";return console.error("[Background] Failed to inject content script:",c),c.includes("Cannot access")&&console.warn("[Background] No permission to inject script on this page"),await r(e.id)}if(n)try{console.log("[Background] Sending EXTRACT_PAGE_INFO request...");const s=await a(e.id,i,5e3);return s.success&&s.data?(console.log("[Background] Successfully extracted page info"),s):(console.warn("[Background] Invalid response from content script:",s),await r(e.id))}catch(s){return console.error("[Background] Failed to extract page info:",s),await r(e.id)}return console.warn("[Background] All extraction attempts failed, returning basic info"),await r(e.id)}case"RECOMMEND_TAGS":{const e=i.payload;return{success:!0,data:await y.recommendTags(e)}}case"SAVE_BOOKMARK":try{const e=i.payload;return{success:!0,data:await P.saveBookmark(e)}}catch(e){return console.error("[Background] Failed to save bookmark:",e),{success:!1,error:e instanceof Error?e.message:"Failed to save bookmark"}}case"SYNC_CACHE":{const e=await E.fullSync();return{success:e.success,data:e,error:e.error}}case"GET_EXISTING_TAGS":try{return{success:!0,data:await h.getTags()}}catch(e){return console.error("[Background] Failed to get existing tags:",e),{success:!1,error:e instanceof Error?e.message:"Failed to load tags"}}case"UPDATE_BOOKMARK_TAGS":try{const{bookmarkId:e,tags:o}=i.payload;return console.log("[Background] Updating bookmark tags:",e,o),await h.updateBookmarkTags(e,o),{success:!0,data:{message:"Tags updated successfully"}}}catch(e){return console.error("[Background] Failed to update tags:",e),{success:!1,error:e instanceof Error?e.message:"Failed to update tags"}}case"CREATE_SNAPSHOT":try{const{bookmarkId:e,title:o,url:a}=i.payload,[r]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!r||!r.id)throw new Error("No active tab found");let n;try{const s=chrome.tabs.sendMessage(r.id,{type:"CAPTURE_PAGE",options:{inlineCSS:!0,inlineImages:!0,inlineFonts:!1,removeScripts:!0,removeHiddenElements:!1,maxImageSize:5242880,timeout:3e4}}),c=new Promise((d,g)=>{setTimeout(()=>g(new Error("Capture timeout")),35e3)}),u=await Promise.race([s,c]);if(u.success)n=u.html,console.log(`[Background] Captured with SingleFile: ${(u.size/1024).toFixed(1)}KB`);else throw new Error(u.error||"Capture failed")}catch(s){console.log("[Background] SingleFile capture failed, falling back to simple capture:",s);const c=await chrome.scripting.executeScript({target:{tabId:r.id},func:()=>document.documentElement.outerHTML});if(c&&c[0]&&c[0].result)n=c[0].result,console.log("[Background] Simple capture successful");else throw new Error("Failed to capture page content")}return await h.createSnapshot(e,{html_content:n,title:o,url:a}),{success:!0,data:{message:"Snapshot created and saved to local for debugging"}}}catch(e){return console.error("[Background] Failed to create snapshot:",e),{success:!1,error:e instanceof Error?e.message:"Failed to create snapshot"}}case"GET_CONFIG":return{success:!0,data:await p.loadConfig()};default:throw new Error(`Unknown message type: ${i.type}`)}}chrome.action.onClicked.addListener(async i=>{console.log("[Background] Extension icon clicked for tab:",i.id)});console.log("[Background] Service worker initialized");
