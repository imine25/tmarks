import{S as p,g as C,d as l,P as T}from"./index-DlUqGJ2w.js";import{A as m,g as I}from"./index-B3uGW65S.js";import{c as _}from"./index-AGxGDhI7.js";import"./prompts-CZcZabTo.js";class v{client=null;async initialize(){const t=await p.getBookmarkSiteApiUrl(),e=await p.getBookmarkSiteApiKey();if(!e)throw new m("API_KEY_INVALID","API Key not found. Please configure your TMarks API key in the extension settings (Options page).");let a;t?t.endsWith("/api")?a=t:a=C(t).API_BASE:a=C().API_BASE,this.client=_({apiKey:e,baseUrl:a})}async ensureClient(){if(this.client||await this.initialize(),!this.client)throw new m("API_KEY_INVALID","API Key not found. Failed to initialize TMarks client. Please configure your API key in the extension settings.");return this.client}async getTags(){const t=await this.ensureClient();try{return(await t.tags.getTags()).data.tags.map(a=>({name:a.name,color:a.color,count:a.bookmark_count||0,createdAt:new Date(a.created_at).getTime()}))}catch(e){throw e.code==="MISSING_API_KEY"?new m("API_KEY_INVALID","TMarks API key is required. Please configure your API key in the extension settings.",{originalError:e}):new m("BOOKMARK_SITE_ERROR",`Failed to fetch tags: ${e.message}`,{originalError:e})}}async getBookmarks(t=1,e=100){const a=await this.ensureClient();try{const o=await a.bookmarks.getBookmarks({page_size:e,page_cursor:t>1?`page_${t}`:void 0});return o.data.bookmarks.length?{bookmarks:o.data.bookmarks.map(s=>({url:s.url,title:s.title,description:s.description||"",tags:s.tags.map(n=>n.name),createdAt:new Date(s.created_at).getTime(),remoteId:s.id,isPublic:s.is_public})),hasMore:o.data.meta.has_more}:{bookmarks:[],hasMore:!1}}catch(o){throw new m("BOOKMARK_SITE_ERROR",`Failed to fetch bookmarks: ${o.message}`,{originalError:o})}}async addBookmark(t){const e=await this.ensureClient();try{const a=await e.bookmarks.createBookmark({title:t.title,url:t.url,description:t.description,cover_image:t.thumbnail,favicon:t.favicon,tags:t.tags,is_public:t.isPublic??!1});if(!a.data.bookmark)throw new m("BOOKMARK_SITE_ERROR","Failed to add bookmark: No data returned");const o=a.meta?.code==="BOOKMARK_EXISTS";return o?(console.log("[BookmarkAPI] 书签已存在, ID:",a.data.bookmark.id),{id:a.data.bookmark.id,isExisting:o,existingBookmark:a.data.bookmark}):(console.log("[BookmarkAPI] 书签创建成功, ID:",a.data.bookmark.id),{id:a.data.bookmark.id,isExisting:o})}catch(a){const o=a.message||"Unknown error";throw new m("BOOKMARK_SITE_ERROR",`Failed to add bookmark: ${o}`,{originalError:a})}}async updateBookmarkTags(t,e){const a=await this.ensureClient();try{console.log("[BookmarkAPI] Updating tags for bookmark:",t,e),await a.bookmarks.updateBookmark(t,{tags:e}),console.log("[BookmarkAPI] Tags updated successfully")}catch(o){throw new m("BOOKMARK_SITE_ERROR",`Failed to update tags: ${o.message}`,{originalError:o})}}async createSnapshot(t,e){const a=await this.ensureClient();try{await a.snapshots.createSnapshot(t,e),console.log("[BookmarkAPI] Snapshot created successfully for bookmark:",t)}catch(o){throw new m("BOOKMARK_SITE_ERROR",`Failed to create snapshot: ${o.message}`,{originalError:o})}}async createSnapshotV2(t,e){await this.ensureClient();try{const a=await p.getBookmarkSiteApiKey(),o=await p.getBookmarkSiteApiUrl();let r;o?o.endsWith("/api")?r=o:r=C(o).API_BASE:r=C().API_BASE;const s=await fetch(`${r}/tab/bookmarks/${t}/snapshots-v2`,{method:"POST",headers:{"Content-Type":"application/json","X-API-Key":a},body:JSON.stringify(e)});if(!s.ok){const n=await s.json();throw new Error(n.error?.message||"Failed to create snapshot")}console.log("[BookmarkAPI] Snapshot V2 created successfully for bookmark:",t)}catch(a){throw new m("BOOKMARK_SITE_ERROR",`Failed to create snapshot (V2): ${a.message}`,{originalError:a})}}async testConnection(){try{return await(await this.ensureClient()).user.getMe(),!0}catch(t){return console.error("API connection test failed:",t),!1}}}const h=new v;class b{contextCache=null;contextPromise=null;async recommendTags(t){try{const e=p.loadConfig(),a=this.getContext(),o=await e,r=o.aiConfig.apiKeys[o.aiConfig.provider];if(!r)return console.warn("[TagRecommender] No API key configured, using fallback"),this.fallbackRecommendation(t);const s=await a,n={page:{title:t.title,url:t.url,description:t.description,content:t.content?.substring(0,500)},context:s,options:{maxTags:o.preferences.maxSuggestedTags||5,preferExisting:!0}},c=o.aiConfig.apiUrls?.[o.aiConfig.provider],u=o.aiConfig.enableCustomPrompt?o.aiConfig.customPrompt:void 0,d=await this.callAIWithRetry(n,r,o.aiConfig.provider,o.aiConfig.model,c,u,1,void 0),g=s.existingTags,k=new Set(g.map(f=>f.trim().toLowerCase()));console.log("[TagRecommender] 开始修正 isNew 字段, 已有标签数量:",g.length),console.log("[TagRecommender] AI 返回的标签:",d.suggestedTags);const w=d.suggestedTags.map(f=>{const S=f.name.trim().toLowerCase(),A=k.has(S),x={...f,isNew:!A};return console.log(`[TagRecommender] 标签 "${f.name}": AI判断 isNew=${f.isNew}, 实际应为 isNew=${x.isNew}, 在已有标签中? ${A}`),x}),B=this.deduplicateAndSort(w);return console.log("[TagRecommender] 已修正 isNew 字段 (最终结果):",B),{tags:B,source:"ai",timestamp:Date.now()}}catch(e){console.error("[TagRecommender] AI recommendation failed:",e);const a=e instanceof Error?e.message:"AI recommendation failed";return this.fallbackRecommendation(t,a)}}async getContext(){if(this.contextCache)return this.contextCache;if(this.contextPromise)return this.contextPromise;this.contextPromise=this.loadContextFromDB();try{const t=await this.contextPromise;return this.contextCache=t,t}finally{this.contextPromise=null}}async callAIWithRetry(t,e,a,o,r,s,n,c){const u=I(a);let d;for(let g=0;g<n;g++)try{if(typeof c=="number"&&c>0){const w=new Promise((f,S)=>{setTimeout(()=>S(new Error("AI request timeout")),c)});return await Promise.race([u.generateTags(t,e,o,r,s),w])}return await u.generateTags(t,e,o,r,s)}catch(k){if(d=k,console.error(`[TagRecommender] AI call attempt ${g+1} failed:`,k),g<n-1){const w=Math.pow(2,g)*1e3;await this.delay(w)}}throw d||new Error("AI request failed after retries")}async fallbackRecommendation(t,e){console.log("[TagRecommender] ⚠️ Using fallback recommendation (AI failed)");const a=this.extractKeywords(t.title+" "+(t.description||"")),r=(await l.tags.toArray()).filter(s=>a.some(n=>s.name.toLowerCase().includes(n.toLowerCase())||n.toLowerCase().includes(s.name.toLowerCase()))).sort((s,n)=>(n.count||0)-(s.count||0)).slice(0,3).map(s=>({name:s.name,isNew:!1,confidence:.6}));return console.log("[TagRecommender] Fallback 返回的标签 (全部 isNew=false):",r),{tags:r,source:"fallback",timestamp:Date.now(),message:e||null}}extractKeywords(t){return t.split(/[\s\/\-_、，。！？]+/).map(e=>e.trim()).filter(e=>e.length>1).slice(0,20)}deduplicateAndSort(t){const e=new Set,a=[];for(const o of t){const r=o.name.toLowerCase().trim();e.has(r)||(e.add(r),a.push(o))}return a.sort((o,r)=>r.confidence-o.confidence)}delay(t){return new Promise(e=>setTimeout(e,t))}clearContextCache(){this.contextCache=null}async preloadContext(){if(this.contextPromise){await this.contextPromise;return}const t=this.loadContextFromDB(!0);this.contextPromise=t;try{const e=await t;this.contextCache=e}finally{this.contextPromise=null}}async refreshContextFromDB(){const t=this.loadContextFromDB(!0);this.contextPromise=t;try{const e=await t;this.contextCache=e}finally{this.contextPromise=null}}updateContextWithBookmark(t){if(!this.contextCache)return;const e=new Set(this.contextCache.existingTags.map(o=>o.toLowerCase())),a=[];for(const o of t.tags){const r=o.trim();r&&(e.has(r.toLowerCase())||(e.add(r.toLowerCase()),a.push(r)))}a.length>0&&(this.contextCache.existingTags=[...this.contextCache.existingTags,...a].slice(-200)),this.contextCache.recentBookmarks=[{title:t.title,tags:t.tags},...this.contextCache.recentBookmarks].slice(0,20)}async loadContextFromDB(t=!1){if(!t&&this.contextCache)return this.contextCache;const[e,a]=await Promise.all([l.tags.orderBy("count").reverse().limit(200).toArray().then(r=>r.map(s=>s.name)),l.bookmarks.orderBy("createdAt").reverse().limit(20).toArray().then(r=>r.map(s=>({title:s.title,tags:s.tags})))]),o={existingTags:e,recentBookmarks:a};return this.contextCache=o,o}}const y=new b;class R{async fullSync(){const t=Date.now();try{console.log("[CacheManager] Starting full sync...");const e=await h.getTags();await l.tags.clear(),await l.tags.bulkAdd(e),console.log(`[CacheManager] Synced ${e.length} tags`);let a=1,o=0;for(await l.bookmarks.clear();a<=T.MAX_PAGES;){const{bookmarks:s,hasMore:n}=await h.getBookmarks(a,T.DEFAULT_PAGE_SIZE);if(s.length>0&&(await l.bookmarks.bulkAdd(s),o+=s.length,console.log(`[CacheManager] Synced page ${a}: ${s.length} bookmarks`)),!n)break;a++}await l.updateLastSyncTime(Date.now()),await l.metadata.put({key:"totalTags",value:e.length,updatedAt:Date.now()}),await l.metadata.put({key:"totalBookmarks",value:o,updatedAt:Date.now()}),await y.refreshContextFromDB();const r=Date.now()-t;return console.log(`[CacheManager] Full sync completed in ${r}ms`),{success:!0,duration:r,stats:{tags:e.length,bookmarks:o}}}catch(e){return console.error("[CacheManager] Full sync failed:",e),{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}async incrementalSync(){try{return await l.getLastSyncTime()===0?this.fullSync():(console.log("[CacheManager] Incremental sync not implemented, falling back to full sync"),this.fullSync())}catch(t){return console.error("[CacheManager] Incremental sync failed:",t),{success:!1,error:t instanceof Error?t.message:"Unknown error"}}}async getStats(){return l.getStats()}async isCacheStale(t=24){const e=await l.getLastSyncTime();if(e===0)return!0;const a=t*60*60*1e3;return Date.now()-e>a}async autoSync(t=24){return await this.isCacheStale(t)?(console.log("[CacheManager] Cache is stale, performing auto sync"),this.incrementalSync()):(console.log("[CacheManager] Cache is fresh, skipping sync"),null)}async clearCache(){await l.clearAll(),y.clearContextCache(),console.log("[CacheManager] Cache cleared")}}const E=new R;class M{async saveBookmark(t){let e,a=!1;try{const o=await h.addBookmark(t);if(e=o.id,a=o.isExisting||!1,a&&o.existingBookmark)return{success:!0,existingBookmark:{...o.existingBookmark,needsDialog:!0},message:"书签已存在"};a?console.log("[BookmarkService] Bookmark already exists, skipping cache update"):(await l.bookmarks.add({url:t.url,title:t.title,description:t.description,tags:t.tags,createdAt:Date.now(),remoteId:o.id,isPublic:t.isPublic??!1}),await this.updateTagCounts(t.tags),y.updateContextWithBookmark({title:t.title,tags:t.tags}))}catch(o){const r=o instanceof Error?o.message:"Unknown error";if(console.error("[BookmarkService] Failed to save bookmark:",r),r.includes("Network"))return await this.queueForLaterSync(t),{success:!0,offline:!0,message:"已暂存,将在网络恢复后同步"};throw o}if(t.createSnapshot&&e)try{console.log("[BookmarkService] Creating snapshot (V2)...");const[o]=await chrome.tabs.query({active:!0,currentWindow:!0});if(o&&o.id){let r;try{const n=chrome.tabs.sendMessage(o.id,{type:"CAPTURE_PAGE_V2",options:{inlineCSS:!0,extractImages:!0,inlineFonts:!1,removeScripts:!0,removeHiddenElements:!1,maxImageSize:10485760,timeout:3e4}}),c=new Promise((d,g)=>{setTimeout(()=>g(new Error("Capture timeout")),35e3)}),u=await Promise.race([n,c]);if(u.success)r=u.data,console.log(`[BookmarkService] Captured (V2): HTML ${(r.html.length/1024).toFixed(1)}KB, ${r.images.length} images`);else throw new Error(u.error||"Capture failed")}catch(n){throw console.error("[BookmarkService] V2 capture failed:",n),n}const s=r.images.map(n=>({hash:n.hash,data:n.data,type:n.type}));await h.createSnapshotV2(e,{html_content:r.html,title:t.title,url:t.url,images:s}),console.log("[BookmarkService] Snapshot V2 created successfully, images:",s.length)}}catch(o){console.error("[BookmarkService] Failed to create snapshot:",o)}return{success:!0,bookmarkId:e,message:a?"书签已存在，已为其创建新快照":void 0}}async updateTagCounts(t){for(const e of t){const a=await l.tags.where("name").equals(e).first();a&&a.id?await l.tags.update(a.id,{count:(a.count||0)+1}):await l.tags.add({name:e,count:1,createdAt:Date.now()})}}async queueForLaterSync(t){await l.metadata.add({key:`pending_${Date.now()}`,value:t,updatedAt:Date.now()}),console.log("[BookmarkService] Bookmark queued for later sync")}async syncPendingBookmarks(){const t=await l.metadata.where("key").startsWith("pending_").toArray();let e=0;for(const a of t)try{if(a.value&&typeof a.value=="object"&&"url"in a.value&&"title"in a.value){const o=a.value;await h.addBookmark(o),await l.metadata.delete(a.key),e++,console.log("[BookmarkService] Synced pending bookmark:",o.title)}}catch(o){console.error("[BookmarkService] Failed to sync pending bookmark:",o)}return console.log(`[BookmarkService] Synced ${e}/${t.length} pending bookmarks`),e}async getPendingCount(){return await l.metadata.where("key").startsWith("pending_").count()}}const P=new M;console.log("[Background] Service worker started");y.preloadContext().catch(i=>{console.error("[Background] Failed to preload AI context:",i)});chrome.runtime.onInstalled.addListener(async i=>{console.log("[Background] Extension installed:",i.reason),i.reason==="install"?console.log("[Background] First time install"):i.reason==="update"&&console.log("[Background] Extension updated")});function F(){const i=new Date,t=new Date(i);return t.setHours(23,0,0,0),t<=i&&t.setDate(t.getDate()+1),t.getTime()-i.getTime()}async function N(){try{const i=await p.loadConfig();if(!i.preferences.autoSync)return;console.log("[Background] Running scheduled auto-sync (23:00)...");const t=await E.autoSync(i.preferences.syncInterval);t&&console.log("[Background] Auto-sync result:",t)}catch(i){console.error("[Background] Auto-sync failed:",i)}}async function K(){const i=()=>{const t=F();console.log("[Background] Next auto-sync scheduled in",Math.round(t/1e3),"seconds"),setTimeout(async()=>{await N(),i()},t)};i()}K().catch(console.error);P.syncPendingBookmarks().catch(console.error);chrome.runtime.onMessage.addListener((i,t,e)=>(O(i).then(a=>e(a)).catch(a=>{console.error("[Background] Message handler error:",a),e({success:!1,error:a instanceof Error?a.message:"Unknown error"})}),!0));async function O(i,t){switch(console.log("[Background] Received message:",i.type),i.type){case"EXTRACT_PAGE_INFO":{const[e]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!e||!e.id)throw new Error("No active tab found");const a=e.url||"";if(a.startsWith("chrome://")||a.startsWith("chrome-extension://")||a.startsWith("edge://")||a.startsWith("about:")||!a)return console.warn("[Background] Cannot access special page:",a),{success:!0,data:{title:e.title||"Untitled",url:a,description:"",content:"",thumbnail:""}};const o=async(n,c,u=3e3)=>Promise.race([chrome.tabs.sendMessage(n,c),new Promise((d,g)=>setTimeout(()=>g(new Error("Message timeout")),u))]),r=async n=>{try{const c=await chrome.tabs.get(n);return{success:!0,data:{title:c.title||"Untitled",url:c.url||"",description:"",content:"",thumbnail:""}}}catch(c){return console.error("[Background] Failed to get tab info:",c),{success:!0,data:{title:"Untitled",url:a,description:"",content:"",thumbnail:""}}}};let s=!1;try{await o(e.id,{type:"PING"},1e3),s=!0,console.log("[Background] Content script is alive")}catch(n){console.warn("[Background] Content script not responding:",n)}if(!s)try{console.log("[Background] Attempting to inject content script...");const c=chrome.runtime.getManifest().content_scripts?.[0];if(!c||!c.js||c.js.length===0)return console.error("[Background] Content script configuration not found in manifest"),await r(e.id);const u=c.js[0];console.log("[Background] Injecting content script from:",u),await chrome.scripting.executeScript({target:{tabId:e.id},files:[u]}),await new Promise(d=>setTimeout(d,300));try{await o(e.id,{type:"PING"},1e3),s=!0,console.log("[Background] Content script injected successfully")}catch(d){return console.error("[Background] Content script injection verification failed:",d),await r(e.id)}}catch(n){const c=n instanceof Error?n.message:"Unknown error";return console.error("[Background] Failed to inject content script:",c),c.includes("Cannot access")&&console.warn("[Background] No permission to inject script on this page"),await r(e.id)}if(s)try{console.log("[Background] Sending EXTRACT_PAGE_INFO request...");const n=await o(e.id,i,5e3);return n.success&&n.data?(console.log("[Background] Successfully extracted page info"),n):(console.warn("[Background] Invalid response from content script:",n),await r(e.id))}catch(n){return console.error("[Background] Failed to extract page info:",n),await r(e.id)}return console.warn("[Background] All extraction attempts failed, returning basic info"),await r(e.id)}case"RECOMMEND_TAGS":{const e=i.payload;return{success:!0,data:await y.recommendTags(e)}}case"SAVE_BOOKMARK":try{const e=i.payload;return{success:!0,data:await P.saveBookmark(e)}}catch(e){return console.error("[Background] Failed to save bookmark:",e),{success:!1,error:e instanceof Error?e.message:"Failed to save bookmark"}}case"SYNC_CACHE":{const e=await E.fullSync();return{success:e.success,data:e,error:e.error}}case"GET_EXISTING_TAGS":try{return{success:!0,data:await h.getTags()}}catch(e){return console.error("[Background] Failed to get existing tags:",e),{success:!1,error:e instanceof Error?e.message:"Failed to load tags"}}case"UPDATE_BOOKMARK_TAGS":try{const{bookmarkId:e,tags:a}=i.payload;return console.log("[Background] Updating bookmark tags:",e,a),await h.updateBookmarkTags(e,a),{success:!0,data:{message:"Tags updated successfully"}}}catch(e){return console.error("[Background] Failed to update tags:",e),{success:!1,error:e instanceof Error?e.message:"Failed to update tags"}}case"CREATE_SNAPSHOT":try{const{bookmarkId:e,title:a,url:o}=i.payload,[r]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!r||!r.id)throw new Error("No active tab found");console.log("[Background] Starting snapshot capture (V2)...");let s;try{const c=chrome.tabs.sendMessage(r.id,{type:"CAPTURE_PAGE_V2",options:{inlineCSS:!0,extractImages:!0,inlineFonts:!1,removeScripts:!0,removeHiddenElements:!1,maxImageSize:10485760,timeout:3e4}}),u=new Promise((g,k)=>{setTimeout(()=>k(new Error("Capture timeout")),35e3)}),d=await Promise.race([c,u]);if(d.success)s=d.data,console.log(`[Background] Captured (V2): HTML ${(s.html.length/1024).toFixed(1)}KB, ${s.images.length} images`);else throw new Error(d.error||"Capture failed")}catch(c){throw console.error("[Background] V2 capture failed:",c),c}const n=s.images.map(c=>({hash:c.hash,data:c.data,type:c.type}));return await h.createSnapshotV2(e,{html_content:s.html,title:a,url:o,images:n}),{success:!0,data:{message:"Snapshot created successfully (V2)",imageCount:n.length}}}catch(e){return console.error("[Background] Failed to create snapshot:",e),{success:!1,error:e instanceof Error?e.message:"Failed to create snapshot"}}case"GET_CONFIG":return{success:!0,data:await p.loadConfig()};default:throw new Error(`Unknown message type: ${i.type}`)}}chrome.action.onClicked.addListener(async i=>{console.log("[Background] Extension icon clicked for tab:",i.id)});console.log("[Background] Service worker initialized");
