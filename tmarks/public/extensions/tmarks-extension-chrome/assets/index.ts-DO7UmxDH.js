import{_ as E}from"./preload-helper-BXl3LOEh.js";import{S as p,g as x,d as l,P as T}from"./index-DlUqGJ2w.js";import{A as m,g as I}from"./index-B3uGW65S.js";import{c as v}from"./index-udhRfuq7.js";import"./prompts-CZcZabTo.js";class b{client=null;async initialize(){const t=await p.getBookmarkSiteApiUrl(),e=await p.getBookmarkSiteApiKey();if(!e)throw new m("API_KEY_INVALID","TMarks API key is required. Please configure your API key in the extension settings.");let a;t?t.endsWith("/api")?a=t:a=x(t).API_BASE:a=x().API_BASE,this.client=v({apiKey:e,baseUrl:a})}async ensureClient(){if(this.client||await this.initialize(),!this.client)throw new m("API_KEY_INVALID","Failed to initialize TMarks client");return this.client}async getTags(){const t=await this.ensureClient();try{return(await t.tags.getTags()).data.tags.map(a=>({name:a.name,color:a.color,count:a.bookmark_count||0,createdAt:new Date(a.created_at).getTime()}))}catch(e){throw e.code==="MISSING_API_KEY"?new m("API_KEY_INVALID","TMarks API key is required. Please configure your API key in the extension settings.",{originalError:e}):new m("BOOKMARK_SITE_ERROR",`Failed to fetch tags: ${e.message}`,{originalError:e})}}async getBookmarks(t=1,e=100){const a=await this.ensureClient();try{const o=await a.bookmarks.getBookmarks({page_size:e,page_cursor:t>1?`page_${t}`:void 0});return o.data.bookmarks.length?{bookmarks:o.data.bookmarks.map(n=>({url:n.url,title:n.title,description:n.description||"",tags:n.tags.map(c=>c.name),createdAt:new Date(n.created_at).getTime(),remoteId:n.id,isPublic:n.is_public})),hasMore:o.data.meta.has_more}:{bookmarks:[],hasMore:!1}}catch(o){throw new m("BOOKMARK_SITE_ERROR",`Failed to fetch bookmarks: ${o.message}`,{originalError:o})}}async addBookmark(t){const e=await this.ensureClient();try{const a=await e.bookmarks.createBookmark({title:t.title,url:t.url,description:t.description,cover_image:t.thumbnail,favicon:t.favicon,tags:t.tags,is_public:t.isPublic??!1});if(!a.data.bookmark)throw new m("BOOKMARK_SITE_ERROR","Failed to add bookmark: No data returned");const o=a.meta?.code==="BOOKMARK_EXISTS";return o?(console.log("[BookmarkAPI] 书签已存在, ID:",a.data.bookmark.id),{id:a.data.bookmark.id,isExisting:o,existingBookmark:a.data.bookmark}):(console.log("[BookmarkAPI] 书签创建成功, ID:",a.data.bookmark.id),{id:a.data.bookmark.id,isExisting:o})}catch(a){const o=a.message||"Unknown error";throw new m("BOOKMARK_SITE_ERROR",`Failed to add bookmark: ${o}`,{originalError:a})}}async updateBookmarkTags(t,e){const a=await this.ensureClient();try{console.log("[BookmarkAPI] Updating tags for bookmark:",t,e),await a.bookmarks.updateBookmark(t,{tags:e}),console.log("[BookmarkAPI] Tags updated successfully")}catch(o){throw new m("BOOKMARK_SITE_ERROR",`Failed to update tags: ${o.message}`,{originalError:o})}}async createSnapshot(t,e){const a=await this.ensureClient();try{await a.snapshots.createSnapshot(t,e),console.log("[BookmarkAPI] Snapshot created successfully for bookmark:",t)}catch(o){throw new m("BOOKMARK_SITE_ERROR",`Failed to create snapshot: ${o.message}`,{originalError:o})}}async testConnection(){try{return await(await this.ensureClient()).user.getMe(),!0}catch(t){return console.error("API connection test failed:",t),!1}}}const h=new b;class R{contextCache=null;contextPromise=null;async recommendTags(t){try{const e=p.loadConfig(),a=this.getContext(),o=await e,r=o.aiConfig.apiKeys[o.aiConfig.provider];if(!r)return console.warn("[TagRecommender] No API key configured, using fallback"),this.fallbackRecommendation(t);const n=await a,c={page:{title:t.title,url:t.url,description:t.description,content:t.content?.substring(0,500)},context:n,options:{maxTags:o.preferences.maxSuggestedTags||5,preferExisting:!0}},i=o.aiConfig.apiUrls?.[o.aiConfig.provider],g=o.aiConfig.enableCustomPrompt?o.aiConfig.customPrompt:void 0,u=await this.callAIWithRetry(c,r,o.aiConfig.provider,o.aiConfig.model,i,g,1,void 0),d=n.existingTags,w=new Set(d.map(k=>k.trim().toLowerCase()));console.log("[TagRecommender] 开始修正 isNew 字段, 已有标签数量:",d.length),console.log("[TagRecommender] AI 返回的标签:",u.suggestedTags);const f=u.suggestedTags.map(k=>{const B=k.name.trim().toLowerCase(),S=w.has(B),A={...k,isNew:!S};return console.log(`[TagRecommender] 标签 "${k.name}": AI判断 isNew=${k.isNew}, 实际应为 isNew=${A.isNew}, 在已有标签中? ${S}`),A}),C=this.deduplicateAndSort(f);return console.log("[TagRecommender] 已修正 isNew 字段 (最终结果):",C),{tags:C,source:"ai",timestamp:Date.now()}}catch(e){console.error("[TagRecommender] AI recommendation failed:",e);const a=e instanceof Error?e.message:"AI recommendation failed";return this.fallbackRecommendation(t,a)}}async getContext(){if(this.contextCache)return this.contextCache;if(this.contextPromise)return this.contextPromise;this.contextPromise=this.loadContextFromDB();try{const t=await this.contextPromise;return this.contextCache=t,t}finally{this.contextPromise=null}}async callAIWithRetry(t,e,a,o,r,n,c,i){const g=I(a);let u;for(let d=0;d<c;d++)try{if(typeof i=="number"&&i>0){const f=new Promise((k,B)=>{setTimeout(()=>B(new Error("AI request timeout")),i)});return await Promise.race([g.generateTags(t,e,o,r,n),f])}return await g.generateTags(t,e,o,r,n)}catch(w){if(u=w,console.error(`[TagRecommender] AI call attempt ${d+1} failed:`,w),d<c-1){const f=Math.pow(2,d)*1e3;await this.delay(f)}}throw u||new Error("AI request failed after retries")}async fallbackRecommendation(t,e){console.log("[TagRecommender] ⚠️ Using fallback recommendation (AI failed)");const a=this.extractKeywords(t.title+" "+(t.description||"")),r=(await l.tags.toArray()).filter(n=>a.some(c=>n.name.toLowerCase().includes(c.toLowerCase())||c.toLowerCase().includes(n.name.toLowerCase()))).sort((n,c)=>(c.count||0)-(n.count||0)).slice(0,3).map(n=>({name:n.name,isNew:!1,confidence:.6}));return console.log("[TagRecommender] Fallback 返回的标签 (全部 isNew=false):",r),{tags:r,source:"fallback",timestamp:Date.now(),message:e||null}}extractKeywords(t){return t.split(/[\s\/\-_、，。！？]+/).map(e=>e.trim()).filter(e=>e.length>1).slice(0,20)}deduplicateAndSort(t){const e=new Set,a=[];for(const o of t){const r=o.name.toLowerCase().trim();e.has(r)||(e.add(r),a.push(o))}return a.sort((o,r)=>r.confidence-o.confidence)}delay(t){return new Promise(e=>setTimeout(e,t))}clearContextCache(){this.contextCache=null}async preloadContext(){if(this.contextPromise){await this.contextPromise;return}const t=this.loadContextFromDB(!0);this.contextPromise=t;try{const e=await t;this.contextCache=e}finally{this.contextPromise=null}}async refreshContextFromDB(){const t=this.loadContextFromDB(!0);this.contextPromise=t;try{const e=await t;this.contextCache=e}finally{this.contextPromise=null}}updateContextWithBookmark(t){if(!this.contextCache)return;const e=new Set(this.contextCache.existingTags.map(o=>o.toLowerCase())),a=[];for(const o of t.tags){const r=o.trim();r&&(e.has(r.toLowerCase())||(e.add(r.toLowerCase()),a.push(r)))}a.length>0&&(this.contextCache.existingTags=[...this.contextCache.existingTags,...a].slice(-200)),this.contextCache.recentBookmarks=[{title:t.title,tags:t.tags},...this.contextCache.recentBookmarks].slice(0,20)}async loadContextFromDB(t=!1){if(!t&&this.contextCache)return this.contextCache;const[e,a]=await Promise.all([l.tags.orderBy("count").reverse().limit(200).toArray().then(r=>r.map(n=>n.name)),l.bookmarks.orderBy("createdAt").reverse().limit(20).toArray().then(r=>r.map(n=>({title:n.title,tags:n.tags})))]),o={existingTags:e,recentBookmarks:a};return this.contextCache=o,o}}const y=new R;class M{async fullSync(){const t=Date.now();try{console.log("[CacheManager] Starting full sync...");const e=await h.getTags();await l.tags.clear(),await l.tags.bulkAdd(e),console.log(`[CacheManager] Synced ${e.length} tags`);let a=1,o=0;for(await l.bookmarks.clear();a<=T.MAX_PAGES;){const{bookmarks:n,hasMore:c}=await h.getBookmarks(a,T.DEFAULT_PAGE_SIZE);if(n.length>0&&(await l.bookmarks.bulkAdd(n),o+=n.length,console.log(`[CacheManager] Synced page ${a}: ${n.length} bookmarks`)),!c)break;a++}await l.updateLastSyncTime(Date.now()),await l.metadata.put({key:"totalTags",value:e.length,updatedAt:Date.now()}),await l.metadata.put({key:"totalBookmarks",value:o,updatedAt:Date.now()}),await y.refreshContextFromDB();const r=Date.now()-t;return console.log(`[CacheManager] Full sync completed in ${r}ms`),{success:!0,duration:r,stats:{tags:e.length,bookmarks:o}}}catch(e){return console.error("[CacheManager] Full sync failed:",e),{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}async incrementalSync(){try{return await l.getLastSyncTime()===0?this.fullSync():(console.log("[CacheManager] Incremental sync not implemented, falling back to full sync"),this.fullSync())}catch(t){return console.error("[CacheManager] Incremental sync failed:",t),{success:!1,error:t instanceof Error?t.message:"Unknown error"}}}async getStats(){return l.getStats()}async isCacheStale(t=24){const e=await l.getLastSyncTime();if(e===0)return!0;const a=t*60*60*1e3;return Date.now()-e>a}async autoSync(t=24){return await this.isCacheStale(t)?(console.log("[CacheManager] Cache is stale, performing auto sync"),this.incrementalSync()):(console.log("[CacheManager] Cache is fresh, skipping sync"),null)}async clearCache(){await l.clearAll(),y.clearContextCache(),console.log("[CacheManager] Cache cleared")}}const P=new M;class F{async saveBookmark(t){let e,a=!1;try{const o=await h.addBookmark(t);if(e=o.id,a=o.isExisting||!1,a&&o.existingBookmark)return{success:!0,existingBookmark:{...o.existingBookmark,needsDialog:!0},message:"书签已存在"};a?console.log("[BookmarkService] Bookmark already exists, skipping cache update"):(await l.bookmarks.add({url:t.url,title:t.title,description:t.description,tags:t.tags,createdAt:Date.now(),remoteId:o.id,isPublic:t.isPublic??!1}),await this.updateTagCounts(t.tags),y.updateContextWithBookmark({title:t.title,tags:t.tags}))}catch(o){const r=o instanceof Error?o.message:"Unknown error";if(console.error("[BookmarkService] Failed to save bookmark:",r),r.includes("Network"))return await this.queueForLaterSync(t),{success:!0,offline:!0,message:"已暂存,将在网络恢复后同步"};throw o}if(t.createSnapshot&&e)try{const[o]=await chrome.tabs.query({active:!0,currentWindow:!0});if(o&&o.id){const{capturePageSnapshot:r}=await E(async()=>{const{capturePageSnapshot:c}=await import("./snapshot-service-gz6wcW_P.js");return{capturePageSnapshot:c}},[]),n=await r(o.id);await h.createSnapshot(e,{html_content:n,title:t.title,url:t.url}),console.log("[BookmarkService] Snapshot created successfully")}}catch(o){console.error("[BookmarkService] Failed to create snapshot:",o)}return{success:!0,bookmarkId:e,message:a?"书签已存在，已为其创建新快照":void 0}}async updateTagCounts(t){for(const e of t){const a=await l.tags.where("name").equals(e).first();a&&a.id?await l.tags.update(a.id,{count:(a.count||0)+1}):await l.tags.add({name:e,count:1,createdAt:Date.now()})}}async queueForLaterSync(t){await l.metadata.add({key:`pending_${Date.now()}`,value:t,updatedAt:Date.now()}),console.log("[BookmarkService] Bookmark queued for later sync")}async syncPendingBookmarks(){const t=await l.metadata.where("key").startsWith("pending_").toArray();let e=0;for(const a of t)try{if(a.value&&typeof a.value=="object"&&"url"in a.value&&"title"in a.value){const o=a.value;await h.addBookmark(o),await l.metadata.delete(a.key),e++,console.log("[BookmarkService] Synced pending bookmark:",o.title)}}catch(o){console.error("[BookmarkService] Failed to sync pending bookmark:",o)}return console.log(`[BookmarkService] Synced ${e}/${t.length} pending bookmarks`),e}async getPendingCount(){return await l.metadata.where("key").startsWith("pending_").count()}}const _=new F;console.log("[Background] Service worker started");y.preloadContext().catch(s=>{console.error("[Background] Failed to preload AI context:",s)});chrome.runtime.onInstalled.addListener(async s=>{console.log("[Background] Extension installed:",s.reason),s.reason==="install"?console.log("[Background] First time install"):s.reason==="update"&&console.log("[Background] Extension updated")});function D(){const s=new Date,t=new Date(s);return t.setHours(23,0,0,0),t<=s&&t.setDate(t.getDate()+1),t.getTime()-s.getTime()}async function N(){try{const s=await p.loadConfig();if(!s.preferences.autoSync)return;console.log("[Background] Running scheduled auto-sync (23:00)...");const t=await P.autoSync(s.preferences.syncInterval);t&&console.log("[Background] Auto-sync result:",t)}catch(s){console.error("[Background] Auto-sync failed:",s)}}async function O(){const s=()=>{const t=D();console.log("[Background] Next auto-sync scheduled in",Math.round(t/1e3),"seconds"),setTimeout(async()=>{await N(),s()},t)};s()}O().catch(console.error);_.syncPendingBookmarks().catch(console.error);chrome.runtime.onMessage.addListener((s,t,e)=>(K(s).then(a=>e(a)).catch(a=>{console.error("[Background] Message handler error:",a),e({success:!1,error:a instanceof Error?a.message:"Unknown error"})}),!0));async function K(s,t){switch(console.log("[Background] Received message:",s.type),s.type){case"EXTRACT_PAGE_INFO":{const[e]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!e||!e.id)throw new Error("No active tab found");const a=e.url||"";if(a.startsWith("chrome://")||a.startsWith("chrome-extension://")||a.startsWith("edge://")||a.startsWith("about:")||!a)return console.warn("[Background] Cannot access special page:",a),{success:!0,data:{title:e.title||"Untitled",url:a,description:"",content:"",thumbnail:""}};const o=async(c,i,g=3e3)=>Promise.race([chrome.tabs.sendMessage(c,i),new Promise((u,d)=>setTimeout(()=>d(new Error("Message timeout")),g))]),r=async c=>{try{const i=await chrome.tabs.get(c);return{success:!0,data:{title:i.title||"Untitled",url:i.url||"",description:"",content:"",thumbnail:""}}}catch(i){return console.error("[Background] Failed to get tab info:",i),{success:!0,data:{title:"Untitled",url:a,description:"",content:"",thumbnail:""}}}};let n=!1;try{await o(e.id,{type:"PING"},1e3),n=!0,console.log("[Background] Content script is alive")}catch(c){console.warn("[Background] Content script not responding:",c)}if(!n)try{console.log("[Background] Attempting to inject content script...");const i=chrome.runtime.getManifest().content_scripts?.[0];if(!i||!i.js||i.js.length===0)return console.error("[Background] Content script configuration not found in manifest"),await r(e.id);const g=i.js[0];console.log("[Background] Injecting content script from:",g),await chrome.scripting.executeScript({target:{tabId:e.id},files:[g]}),await new Promise(u=>setTimeout(u,300));try{await o(e.id,{type:"PING"},1e3),n=!0,console.log("[Background] Content script injected successfully")}catch(u){return console.error("[Background] Content script injection verification failed:",u),await r(e.id)}}catch(c){const i=c instanceof Error?c.message:"Unknown error";return console.error("[Background] Failed to inject content script:",i),i.includes("Cannot access")&&console.warn("[Background] No permission to inject script on this page"),await r(e.id)}if(n)try{console.log("[Background] Sending EXTRACT_PAGE_INFO request...");const c=await o(e.id,s,5e3);return c.success&&c.data?(console.log("[Background] Successfully extracted page info"),c):(console.warn("[Background] Invalid response from content script:",c),await r(e.id))}catch(c){return console.error("[Background] Failed to extract page info:",c),await r(e.id)}return console.warn("[Background] All extraction attempts failed, returning basic info"),await r(e.id)}case"RECOMMEND_TAGS":{const e=s.payload;return{success:!0,data:await y.recommendTags(e)}}case"SAVE_BOOKMARK":try{const e=s.payload;return{success:!0,data:await _.saveBookmark(e)}}catch(e){return console.error("[Background] Failed to save bookmark:",e),{success:!1,error:e instanceof Error?e.message:"Failed to save bookmark"}}case"SYNC_CACHE":{const e=await P.fullSync();return{success:e.success,data:e,error:e.error}}case"GET_EXISTING_TAGS":try{return{success:!0,data:await h.getTags()}}catch(e){return console.error("[Background] Failed to get existing tags:",e),{success:!1,error:e instanceof Error?e.message:"Failed to load tags"}}case"UPDATE_BOOKMARK_TAGS":try{const{bookmarkId:e,tags:a}=s.payload;return console.log("[Background] Updating bookmark tags:",e,a),await h.updateBookmarkTags(e,a),{success:!0,data:{message:"Tags updated successfully"}}}catch(e){return console.error("[Background] Failed to update tags:",e),{success:!1,error:e instanceof Error?e.message:"Failed to update tags"}}case"CREATE_SNAPSHOT":try{const{bookmarkId:e,title:a,url:o}=s.payload,[r]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!r||!r.id)throw new Error("No active tab found");const{capturePageSnapshot:n}=await E(async()=>{const{capturePageSnapshot:i}=await import("./snapshot-service-gz6wcW_P.js");return{capturePageSnapshot:i}},[]),c=await n(r.id);return await h.createSnapshot(e,{html_content:c,title:a,url:o}),{success:!0,data:{message:"Snapshot created successfully"}}}catch(e){return console.error("[Background] Failed to create snapshot:",e),{success:!1,error:e instanceof Error?e.message:"Failed to create snapshot"}}case"GET_CONFIG":return{success:!0,data:await p.loadConfig()};default:throw new Error(`Unknown message type: ${s.type}`)}}chrome.action.onClicked.addListener(async s=>{console.log("[Background] Extension icon clicked for tab:",s.id)});console.log("[Background] Service worker initialized");
