import{S as p,g as x,d as l,P as S}from"./index-DlUqGJ2w.js";import{A as h,g as E}from"./index-C43BmuZN.js";import{c as _}from"./index-udhRfuq7.js";import{_ as v}from"./prompts-Dz0Snwak.js";class R{client=null;async initialize(){const e=await p.getBookmarkSiteApiUrl(),t=await p.getBookmarkSiteApiKey();if(!t)throw new h("API_KEY_INVALID","TMarks API key is required. Please configure your API key in the extension settings.");let o;e?e.endsWith("/api")?o=e:o=x(e).API_BASE:o=x().API_BASE,this.client=_({apiKey:t,baseUrl:o})}async ensureClient(){if(this.client||await this.initialize(),!this.client)throw new h("API_KEY_INVALID","Failed to initialize TMarks client");return this.client}async getTags(){const e=await this.ensureClient();try{return(await e.tags.getTags()).data.tags.map(o=>({name:o.name,color:o.color,count:o.bookmark_count||0,createdAt:new Date(o.created_at).getTime()}))}catch(t){throw t.code==="MISSING_API_KEY"?new h("API_KEY_INVALID","TMarks API key is required. Please configure your API key in the extension settings.",{originalError:t}):new h("BOOKMARK_SITE_ERROR",`Failed to fetch tags: ${t.message}`,{originalError:t})}}async getBookmarks(e=1,t=100){const o=await this.ensureClient();try{const a=await o.bookmarks.getBookmarks({page_size:t,page_cursor:e>1?`page_${e}`:void 0});return a.data.bookmarks.length?{bookmarks:a.data.bookmarks.map(r=>({url:r.url,title:r.title,description:r.description||"",tags:r.tags.map(s=>s.name),createdAt:new Date(r.created_at).getTime(),remoteId:r.id,isPublic:r.is_public})),hasMore:a.data.meta.has_more}:{bookmarks:[],hasMore:!1}}catch(a){throw new h("BOOKMARK_SITE_ERROR",`Failed to fetch bookmarks: ${a.message}`,{originalError:a})}}async addBookmark(e){const t=await this.ensureClient();try{let o=[];if(e.tags&&e.tags.length>0){console.log("[BookmarkAPI] 处理标签:",e.tags);const s=(await t.tags.getTags()).data.tags;console.log("[BookmarkAPI] 已有标签数量:",s.length);for(const i of e.tags){const u=s.find(g=>g.name.toLowerCase()===i.toLowerCase());if(u)console.log(`[BookmarkAPI] 标签 "${i}" 已存在, ID: ${u.id}`),o.push(u.id);else{console.log(`[BookmarkAPI] 标签 "${i}" 不存在，正在创建...`);try{const g=await t.tags.createTag({name:i}),d=g.data.tag.id;console.log(`[BookmarkAPI] 标签 "${i}" 创建成功, ID: ${d}`),o.push(d),s.push(g.data.tag)}catch(g){if(g.code==="DUPLICATE_TAG"){console.log(`[BookmarkAPI] 标签 "${i}" 已被并发创建，重新查找...`);const m=(await t.tags.getTags()).data.tags.find(w=>w.name.toLowerCase()===i.toLowerCase());if(m)o.push(m.id),console.log(`[BookmarkAPI] 重新找到标签 "${i}", ID: ${m.id}`);else throw console.error(`[BookmarkAPI] 无法创建或找到标签 "${i}"`),g}else throw console.error(`[BookmarkAPI] 创建标签 "${i}" 失败:`,g),g}}}console.log("[BookmarkAPI] 最终标签 IDs:",o)}const a=await t.bookmarks.createBookmark({title:e.title,url:e.url,description:e.description,cover_image:e.thumbnail,favicon:e.favicon,tag_ids:o,is_public:e.isPublic??!1});if(!a.data.bookmark)throw new h("BOOKMARK_SITE_ERROR","Failed to add bookmark: No data returned");const n=a.meta?.code==="BOOKMARK_EXISTS";return console.log(n?"[BookmarkAPI] 书签已存在, ID:":"[BookmarkAPI] 书签创建成功, ID:",a.data.bookmark.id),{id:a.data.bookmark.id,isExisting:n}}catch(o){throw new h("BOOKMARK_SITE_ERROR",`Failed to add bookmark: ${o.message}`,{originalError:o})}}async createSnapshot(e,t){const o=await this.ensureClient();try{await o.snapshots.createSnapshot(e,t),console.log("[BookmarkAPI] Snapshot created successfully for bookmark:",e)}catch(a){throw new h("BOOKMARK_SITE_ERROR",`Failed to create snapshot: ${a.message}`,{originalError:a})}}async testConnection(){try{return await(await this.ensureClient()).user.getMe(),!0}catch(e){return console.error("API connection test failed:",e),!1}}}const k=new R;class M{contextCache=null;contextPromise=null;async recommendTags(e){try{const t=p.loadConfig(),o=this.getContext(),a=await t,n=a.aiConfig.apiKeys[a.aiConfig.provider];if(!n)return console.warn("[TagRecommender] No API key configured, using fallback"),this.fallbackRecommendation(e);const r=await o,s={page:{title:e.title,url:e.url,description:e.description,content:e.content?.substring(0,500)},context:r,options:{maxTags:a.preferences.maxSuggestedTags||5,preferExisting:!0}},i=a.aiConfig.apiUrls?.[a.aiConfig.provider],u=a.aiConfig.enableCustomPrompt?a.aiConfig.customPrompt:void 0,g=await this.callAIWithRetry(s,n,a.aiConfig.provider,a.aiConfig.model,i,u,1,void 0),d=r.existingTags,m=new Set(d.map(f=>f.trim().toLowerCase()));console.log("[TagRecommender] 开始修正 isNew 字段, 已有标签数量:",d.length),console.log("[TagRecommender] AI 返回的标签:",g.suggestedTags);const w=g.suggestedTags.map(f=>{const A=f.name.trim().toLowerCase(),B=m.has(A),T={...f,isNew:!B};return console.log(`[TagRecommender] 标签 "${f.name}": AI判断 isNew=${f.isNew}, 实际应为 isNew=${T.isNew}, 在已有标签中? ${B}`),T}),C=this.deduplicateAndSort(w);return console.log("[TagRecommender] 已修正 isNew 字段 (最终结果):",C),{tags:C,source:"ai",timestamp:Date.now()}}catch(t){console.error("[TagRecommender] AI recommendation failed:",t);const o=t instanceof Error?t.message:"AI recommendation failed";return this.fallbackRecommendation(e,o)}}async getContext(){if(this.contextCache)return this.contextCache;if(this.contextPromise)return this.contextPromise;this.contextPromise=this.loadContextFromDB();try{const e=await this.contextPromise;return this.contextCache=e,e}finally{this.contextPromise=null}}async callAIWithRetry(e,t,o,a,n,r,s,i){const u=E(o);let g;for(let d=0;d<s;d++)try{if(typeof i=="number"&&i>0){const w=new Promise((f,A)=>{setTimeout(()=>A(new Error("AI request timeout")),i)});return await Promise.race([u.generateTags(e,t,a,n,r),w])}return await u.generateTags(e,t,a,n,r)}catch(m){if(g=m,console.error(`[TagRecommender] AI call attempt ${d+1} failed:`,m),d<s-1){const w=Math.pow(2,d)*1e3;await this.delay(w)}}throw g||new Error("AI request failed after retries")}async fallbackRecommendation(e,t){console.log("[TagRecommender] ⚠️ Using fallback recommendation (AI failed)");const o=this.extractKeywords(e.title+" "+(e.description||"")),n=(await l.tags.toArray()).filter(r=>o.some(s=>r.name.toLowerCase().includes(s.toLowerCase())||s.toLowerCase().includes(r.name.toLowerCase()))).sort((r,s)=>(s.count||0)-(r.count||0)).slice(0,3).map(r=>({name:r.name,isNew:!1,confidence:.6}));return console.log("[TagRecommender] Fallback 返回的标签 (全部 isNew=false):",n),{tags:n,source:"fallback",timestamp:Date.now(),message:t||null}}extractKeywords(e){return e.split(/[\s\/\-_、，。！？]+/).map(t=>t.trim()).filter(t=>t.length>1).slice(0,20)}deduplicateAndSort(e){const t=new Set,o=[];for(const a of e){const n=a.name.toLowerCase().trim();t.has(n)||(t.add(n),o.push(a))}return o.sort((a,n)=>n.confidence-a.confidence)}delay(e){return new Promise(t=>setTimeout(t,e))}clearContextCache(){this.contextCache=null}async preloadContext(){if(this.contextPromise){await this.contextPromise;return}const e=this.loadContextFromDB(!0);this.contextPromise=e;try{const t=await e;this.contextCache=t}finally{this.contextPromise=null}}async refreshContextFromDB(){const e=this.loadContextFromDB(!0);this.contextPromise=e;try{const t=await e;this.contextCache=t}finally{this.contextPromise=null}}updateContextWithBookmark(e){if(!this.contextCache)return;const t=new Set(this.contextCache.existingTags.map(a=>a.toLowerCase())),o=[];for(const a of e.tags){const n=a.trim();n&&(t.has(n.toLowerCase())||(t.add(n.toLowerCase()),o.push(n)))}o.length>0&&(this.contextCache.existingTags=[...this.contextCache.existingTags,...o].slice(-200)),this.contextCache.recentBookmarks=[{title:e.title,tags:e.tags},...this.contextCache.recentBookmarks].slice(0,20)}async loadContextFromDB(e=!1){if(!e&&this.contextCache)return this.contextCache;const[t,o]=await Promise.all([l.tags.orderBy("count").reverse().limit(200).toArray().then(n=>n.map(r=>r.name)),l.bookmarks.orderBy("createdAt").reverse().limit(20).toArray().then(n=>n.map(r=>({title:r.title,tags:r.tags})))]),a={existingTags:t,recentBookmarks:o};return this.contextCache=a,a}}const y=new M;class b{async fullSync(){const e=Date.now();try{console.log("[CacheManager] Starting full sync...");const t=await k.getTags();await l.tags.clear(),await l.tags.bulkAdd(t),console.log(`[CacheManager] Synced ${t.length} tags`);let o=1,a=0;for(await l.bookmarks.clear();o<=S.MAX_PAGES;){const{bookmarks:r,hasMore:s}=await k.getBookmarks(o,S.DEFAULT_PAGE_SIZE);if(r.length>0&&(await l.bookmarks.bulkAdd(r),a+=r.length,console.log(`[CacheManager] Synced page ${o}: ${r.length} bookmarks`)),!s)break;o++}await l.updateLastSyncTime(Date.now()),await l.metadata.put({key:"totalTags",value:t.length,updatedAt:Date.now()}),await l.metadata.put({key:"totalBookmarks",value:a,updatedAt:Date.now()}),await y.refreshContextFromDB();const n=Date.now()-e;return console.log(`[CacheManager] Full sync completed in ${n}ms`),{success:!0,duration:n,stats:{tags:t.length,bookmarks:a}}}catch(t){return console.error("[CacheManager] Full sync failed:",t),{success:!1,error:t instanceof Error?t.message:"Unknown error"}}}async incrementalSync(){try{return await l.getLastSyncTime()===0?this.fullSync():(console.log("[CacheManager] Incremental sync not implemented, falling back to full sync"),this.fullSync())}catch(e){return console.error("[CacheManager] Incremental sync failed:",e),{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}async getStats(){return l.getStats()}async isCacheStale(e=24){const t=await l.getLastSyncTime();if(t===0)return!0;const o=e*60*60*1e3;return Date.now()-t>o}async autoSync(e=24){return await this.isCacheStale(e)?(console.log("[CacheManager] Cache is stale, performing auto sync"),this.incrementalSync()):(console.log("[CacheManager] Cache is fresh, skipping sync"),null)}async clearCache(){await l.clearAll(),y.clearContextCache(),console.log("[CacheManager] Cache cleared")}}const I=new b;class D{async saveBookmark(e){let t,o=!1;try{const a=await k.addBookmark(e);t=a.id,o=a.isExisting||!1,o?console.log("[BookmarkService] Bookmark already exists, skipping cache update"):(await l.bookmarks.add({url:e.url,title:e.title,description:e.description,tags:e.tags,createdAt:Date.now(),remoteId:a.id,isPublic:e.isPublic??!1}),await this.updateTagCounts(e.tags),y.updateContextWithBookmark({title:e.title,tags:e.tags}))}catch(a){const n=a instanceof Error?a.message:"Unknown error";if(console.error("[BookmarkService] Failed to save bookmark:",n),n.includes("Network"))return await this.queueForLaterSync(e),{success:!0,offline:!0,message:"已暂存,将在网络恢复后同步"};throw a}if(e.createSnapshot&&t)try{const[a]=await chrome.tabs.query({active:!0,currentWindow:!0});if(a&&a.id){const{capturePageSnapshot:n}=await v(async()=>{const{capturePageSnapshot:s}=await import("./snapshot-service-oiCI2-jo.js");return{capturePageSnapshot:s}},[]),r=await n(a.id);await k.createSnapshot(t,{html_content:r,title:e.title,url:e.url}),console.log("[BookmarkService] Snapshot created successfully")}}catch(a){console.error("[BookmarkService] Failed to create snapshot:",a)}return{success:!0,bookmarkId:t,message:o?"书签已存在，已为其创建新快照":void 0}}async updateTagCounts(e){for(const t of e){const o=await l.tags.where("name").equals(t).first();o&&o.id?await l.tags.update(o.id,{count:(o.count||0)+1}):await l.tags.add({name:t,count:1,createdAt:Date.now()})}}async queueForLaterSync(e){await l.metadata.add({key:`pending_${Date.now()}`,value:e,updatedAt:Date.now()}),console.log("[BookmarkService] Bookmark queued for later sync")}async syncPendingBookmarks(){const e=await l.metadata.where("key").startsWith("pending_").toArray();let t=0;for(const o of e)try{if(o.value&&typeof o.value=="object"&&"url"in o.value&&"title"in o.value){const a=o.value;await k.addBookmark(a),await l.metadata.delete(o.key),t++,console.log("[BookmarkService] Synced pending bookmark:",a.title)}}catch(a){console.error("[BookmarkService] Failed to sync pending bookmark:",a)}return console.log(`[BookmarkService] Synced ${t}/${e.length} pending bookmarks`),t}async getPendingCount(){return await l.metadata.where("key").startsWith("pending_").count()}}const P=new D;console.log("[Background] Service worker started");y.preloadContext().catch(c=>{console.error("[Background] Failed to preload AI context:",c)});chrome.runtime.onInstalled.addListener(async c=>{console.log("[Background] Extension installed:",c.reason),c.reason==="install"?console.log("[Background] First time install"):c.reason==="update"&&console.log("[Background] Extension updated")});function N(){const c=new Date,e=new Date(c);return e.setHours(23,0,0,0),e<=c&&e.setDate(e.getDate()+1),e.getTime()-c.getTime()}async function F(){try{const c=await p.loadConfig();if(!c.preferences.autoSync)return;console.log("[Background] Running scheduled auto-sync (23:00)...");const e=await I.autoSync(c.preferences.syncInterval);e&&console.log("[Background] Auto-sync result:",e)}catch(c){console.error("[Background] Auto-sync failed:",c)}}async function L(){const c=()=>{const e=N();console.log("[Background] Next auto-sync scheduled in",Math.round(e/1e3),"seconds"),setTimeout(async()=>{await F(),c()},e)};c()}L().catch(console.error);P.syncPendingBookmarks().catch(console.error);chrome.runtime.onMessage.addListener((c,e,t)=>($(c).then(o=>t(o)).catch(o=>{console.error("[Background] Message handler error:",o),t({success:!1,error:o instanceof Error?o.message:"Unknown error"})}),!0));async function $(c,e){switch(console.log("[Background] Received message:",c.type),c.type){case"EXTRACT_PAGE_INFO":{const[t]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!t||!t.id)throw new Error("No active tab found");const o=t.url||"";if(o.startsWith("chrome://")||o.startsWith("chrome-extension://")||o.startsWith("edge://")||o.startsWith("about:")||!o)return console.warn("[Background] Cannot access special page:",o),{success:!0,data:{title:t.title||"Untitled",url:o,description:"",content:"",thumbnail:""}};const a=async(s,i,u=3e3)=>Promise.race([chrome.tabs.sendMessage(s,i),new Promise((g,d)=>setTimeout(()=>d(new Error("Message timeout")),u))]),n=async s=>{try{const i=await chrome.tabs.get(s);return{success:!0,data:{title:i.title||"Untitled",url:i.url||"",description:"",content:"",thumbnail:""}}}catch(i){return console.error("[Background] Failed to get tab info:",i),{success:!0,data:{title:"Untitled",url:o,description:"",content:"",thumbnail:""}}}};let r=!1;try{await a(t.id,{type:"PING"},1e3),r=!0,console.log("[Background] Content script is alive")}catch(s){console.warn("[Background] Content script not responding:",s)}if(!r)try{console.log("[Background] Attempting to inject content script...");const i=chrome.runtime.getManifest().content_scripts?.[0];if(!i||!i.js||i.js.length===0)return console.error("[Background] Content script configuration not found in manifest"),await n(t.id);const u=i.js[0];console.log("[Background] Injecting content script from:",u),await chrome.scripting.executeScript({target:{tabId:t.id},files:[u]}),await new Promise(g=>setTimeout(g,300));try{await a(t.id,{type:"PING"},1e3),r=!0,console.log("[Background] Content script injected successfully")}catch(g){return console.error("[Background] Content script injection verification failed:",g),await n(t.id)}}catch(s){const i=s instanceof Error?s.message:"Unknown error";return console.error("[Background] Failed to inject content script:",i),i.includes("Cannot access")&&console.warn("[Background] No permission to inject script on this page"),await n(t.id)}if(r)try{console.log("[Background] Sending EXTRACT_PAGE_INFO request...");const s=await a(t.id,c,5e3);return s.success&&s.data?(console.log("[Background] Successfully extracted page info"),s):(console.warn("[Background] Invalid response from content script:",s),await n(t.id))}catch(s){return console.error("[Background] Failed to extract page info:",s),await n(t.id)}return console.warn("[Background] All extraction attempts failed, returning basic info"),await n(t.id)}case"RECOMMEND_TAGS":{const t=c.payload;return{success:!0,data:await y.recommendTags(t)}}case"SAVE_BOOKMARK":{const t=c.payload;return{success:!0,data:await P.saveBookmark(t)}}case"SYNC_CACHE":{const t=await I.fullSync();return{success:t.success,data:t,error:t.error}}case"GET_EXISTING_TAGS":try{return{success:!0,data:await k.getTags()}}catch(t){return console.error("[Background] Failed to get existing tags:",t),{success:!1,error:t instanceof Error?t.message:"Failed to load tags"}}case"GET_CONFIG":return{success:!0,data:await p.loadConfig()};default:throw new Error(`Unknown message type: ${c.type}`)}}chrome.action.onClicked.addListener(async c=>{console.log("[Background] Extension icon clicked for tab:",c.id)});console.log("[Background] Service worker initialized");
